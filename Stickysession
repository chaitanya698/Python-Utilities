# errors.py
from enum import Enum
import logging
import traceback
from flask import jsonify, request
from werkzeug.exceptions import HTTPException

log = logging.getLogger(__name__)

# ────────────────────────────────────────────────────────────────
# 1.  Canonical error catalogue
# ────────────────────────────────────────────────────────────────
class ComplaintError(Enum):
    # HTTP 422 – processing error in a downstream component
    AI_MODEL_UNAVAILABLE          = ("C-101", 422, "AI model processing not available.")
    CUSTOMER_SEARCH_UNAVAILABLE   = ("C-102", 422, "Customer search processing not available.")
    HR_DATA_UNAVAILABLE           = ("C-103", 422, "HR data processing not available.")
    SUBMISSION_FAILED             = ("C-104", 422, "Complaints submission processing failed or unavailable.")

    # HTTP 500 – service-wide failure
    SERVICE_TEMPORARILY_DOWN      = ("C-100", 500, "Complaints AI temporarily unavailable.")

    # helper properties
    @property
    def sub_code(self):  return self.value[0]

    @property
    def http(self):      return self.value[1]

    @property
    def default_msg(self): return self.value[2]


# ────────────────────────────────────────────────────────────────
# 2.  Base API exception
# ────────────────────────────────────────────────────────────────
class APIException(Exception):
    """
    Base class for everything we *intend* to raise.
    """
    def __init__(
        self,
        catalogue_entry: ComplaintError,
        *,
        message: str | None = None,
        payload: dict | None = None,
    ) -> None:
        self.status_code = catalogue_entry.http
        self.sub_code    = catalogue_entry.sub_code
        self.message     = message or catalogue_entry.default_msg
        self.payload     = payload or {}
        super().__init__(self.message)


# Convenience short-names you can raise from your code
class AIModelUnavailable(APIException):
    def __init__(self, message: str | None = None):
        super().__init__(ComplaintError.AI_MODEL_UNAVAILABLE, message=message)


class CustomerSearchUnavailable(APIException):
    def __init__(self, message: str | None = None):
        super().__init__(ComplaintError.CUSTOMER_SEARCH_UNAVAILABLE, message=message)


class HRDataUnavailable(APIException):
    def __init__(self, message: str | None = None):
        super().__init__(ComplaintError.HR_DATA_UNAVAILABLE, message=message)


class SubmissionFailed(APIException):
    def __init__(self, message: str | None = None):
        super().__init__(ComplaintError.SUBMISSION_FAILED, message=message)


# ────────────────────────────────────────────────────────────────
# 3.  Registration helper – call exactly once in create_app()
# ────────────────────────────────────────────────────────────────
def register_error_handlers(app):
    """
    Attach global Flask error handlers.
    """

    # 3.1 API-level errors we raised on purpose
    @app.errorhandler(APIException)
    def _handle_api_exc(exc: APIException):
        return _json(exc.status_code, exc.sub_code, exc.message)

    # 3.2 Werkzeug routing / abort() errors (404, 405, 400 …)
    @app.errorhandler(HTTPException)
    def _handle_http_exc(exc: HTTPException):
        # Pass through status code, but there is no sub-code – mark "None"
        return _json(exc.code, None, exc.description)

    # 3.3 Absolutely everything else (coding bugs, time-outs, lib errors …)
    @app.errorhandler(Exception)
    def _handle_fallback(exc: Exception):
        # Log the traceback for later inspection
        log.exception(
            "Uncaught exception on %s %s\n%s",
            request.method,
            request.path,
            traceback.format_exc(),
        )
        # Wrap in our generic "service down" definition
        cat = ComplaintError.SERVICE_TEMPORARILY_DOWN
        return _json(cat.http, cat.sub_code, cat.default_msg)

    # Nothing to return – Flask uses the decorated functions


# ────────────────────────────────────────────────────────────────
# 4.  Small helper to build the envelope
# ────────────────────────────────────────────────────────────────
def _json(http_status: int, sub_code: str | None, message: str):
    """
    Normalises every error into one schema:
      { status, code, sub_code, message }
    """
    body = {
        "status": "error",
        "code": http_status,
        "sub_code": sub_code,      # None for plain HTTP errors
        "message": message,
    }
    return jsonify(body), http_status


