import logging
import traceback
import uuid
from flask import jsonify, request, g
from werkzeug.exceptions import HTTPException

# Import our custom exceptions and error enum
from exceptions import APIException, ComplaintException, ComplaintError

logger = logging.getLogger(__name__)

def generate_request_id():
    """Generates a unique request ID (e.g., UUID) for tracing."""
    return str(uuid.uuid4())

def register_exception_handlers(app):
    """
    Registers all global exception handlers with the Flask application.
    """

    @app.before_request
    def before_request():
        """Attach a unique request ID to Flask's global context (g)."""
        g.request_id = generate_request_id()
        logger.debug(f"Request ID generated: {g.request_id} for path: {request.path}")

    @app.errorhandler(ComplaintException)
    def handle_complaint_exception(e: ComplaintException):
        """
        Handles custom ComplaintException instances, which are explicitly raised
        within the application logic.

        This single handler can process all specific application errors,
        including the various errors that share the same HTTP status code (e.g., 422).
        The distinction between errors like AI_MODEL_PROCESSING_ERROR and
        SUBMISSION_PROCESSING_FAILED is maintained because the specific `error_enum`
        is encapsulated within the exception object 'e' itself.
        """
        request_id = getattr(g, 'request_id', 'N/A')
        log_message = (
            f"[{request_id}] ComplaintException Caught: Code={e.error_code}, "
            f"HTTP={e.http_status}, Description='{e.error_enum.description}'"
        )

        if e.details:
            log_message += f", Details='{e.details}'"

        # Log the full traceback for critical server errors (5xx)
        if e.http_status >= 500 and e.original_exception:
            logger.exception(f"{log_message}\nOriginal Exception: {e.original_exception}")
        else:
            logger.warning(log_message)

        response = jsonify(e.to_json())
        response.status_code = e.http_status
        return response

    @app.errorhandler(HTTPException)
    def handle_http_exception(e: HTTPException):
        """
        Handles standard Werkzeug/Flask HTTP exceptions (e.g., 404, 400, 500)
        and maps them to a standardized ComplaintError JSON response.

        This is crucial for catching errors generated by Flask/Werkzeug itself,
        such as a 404 for an undefined route or a 405 for an invalid method.
        """
        request_id = getattr(g, 'request_id', 'N/A')

        # A mapping from HTTP status codes to our custom ComplaintError enum.
        # This provides a structured way to handle common framework-level errors.
        HTTP_CODE_TO_COMPLAINT_ERROR_MAP = {
            400: ComplaintError.BAD_REQUEST,
            # 404 and 405 are mapped to BAD_REQUEST as they represent client errors.
            404: ComplaintError.BAD_REQUEST,
            405: ComplaintError.BAD_REQUEST,
        }
        
        # For all 5xx server errors, we must return a generic service down error.
        if e.code and e.code >= 500:
            error_enum = ComplaintError.SERVICE_TEMPORARILY_DOWN
        else:
            # Use the mapping to find the appropriate custom error.
            # Default to a generic server error for unmapped client-side codes.
            error_enum = HTTP_CODE_TO_COMPLAINT_ERROR_MAP.get(e.code, ComplaintError.SERVICE_TEMPORARILY_DOWN)

        # Log the exception with details about the mapping.
        logger.warning(
            f"[{request_id}] HTTPException Caught: HTTP={e.code}, Mapped to Code={error_enum.code}. "
            f"Original Description: {e.description}"
        )

        # Create a standardized JSON response payload.
        generic_chat_message = "Complaint Capture agent is temporarily unavailable"
        response_payload = {
            "chatResponseText": generic_chat_message,
            "errorResponse": {
                "code": error_enum.code,
                "desc": error_enum.description
            }
        }

        response = jsonify(response_payload)
        # Use the HTTP status from our enum for a consistent response.
        response.status_code = error_enum.http_status
        return response

    @app.errorhandler(Exception)
    def handle_generic_exception(e: Exception):
        """
        Handles ALL uncaught exceptions as a final fallback. This is a critical
        safety net that prevents raw stack traces from being sent to the client.
        This should always return a generic 500-level error.
        """
        request_id = getattr(g, 'request_id', 'N/A')
        error_enum = ComplaintError.SERVICE_TEMPORARILY_DOWN

        # Log the full traceback for all uncaught exceptions for debugging.
        logger.exception(f"[{request_id}] Uncaught Exception. Mapping to {error_enum.code}. Details: {e}")

        # Use the generic chat message for all uncaught exceptions.
        generic_chat_message = "Complaint Capture agent is temporarily unavailable"
        
        response_payload = {
            "chatResponseText": generic_chat_message,
            "errorResponse": {
                "code": error_enum.code,
                "desc": error_enum.description
            }
        }

        response = jsonify(response_payload)
        response.status_code = error_enum.http_status
        return response
